# -*- coding: utf-8 -*-
"""
Created on Mon Mar  7 17:10:21 2022

@author: alalinaci

"""

import random
import matplotlib.pyplot as plt
import numpy as np
import openpyxl
import GetTSFS
import datetime

# Find TS and FS using GetTSFS before solving the multi-objective function
GetTSFS.get_flexural_strength()
GetTSFS.get_tensile_strength()
# Define list that will store all the results generated by GetTSFS.py
tensile_strength_list = []
flexural_strength_list = []
fitness_value_list = []
BO = []
S = []
ID = []
T = []
LT = []
Predicted_Fitness = []

# Fetch data from excel sheet
wb = openpyxl.load_workbook(r'''excel petg.xlsx''', data_only=True)
ws = wb['Data']
for row in range(3,34):  
    for column in "G":
        cell_name = "{}{}".format(column, row)
        tensile_strength_list.append(ws[cell_name].value)
for row in range(3,34):  
    for column in "J":
        cell_name = "{}{}".format(column, row)
        flexural_strength_list.append(ws[cell_name].value)
for row in range(3,34):  
    for column in "L":
        cell_name = "{}{}".format(column, row)
        fitness_value_list.append(ws[cell_name].value)


TSmax = random.choice(tensile_strength_list)
FSmax = random.choice(flexural_strength_list)
w = 0.5

#------------------------------------------------------------------------------
# TO CUSTOMIZE THIS PSO CODE TO SOLVE UNCONSTRAINED OPTIMIZATION PROBLEMS, CHANGE THE PARAMETERS IN THIS SECTION ONLY:
# THE FOLLOWING MULTI-OBJECTIVE FUNCTION IS WEIGHTED SUM OBTAINED FROM 0/1 KNAPSACK PROBLEM USED TO DEFINE A SEARCH SPACE
def objective_function(X): 
    Zmax = w*TSmax+w*FSmax
    return Zmax
    
bounds=[(0.087,0.223),(3.720,6.181)] # upper and lower bounds of variables (TS and FS) obtained through experiment, needs to be fed manually
nv = 2                   # number of variables is taken as one, as we only intend to maximize tensile strength
mm = 1                   # since we're maximizing tensile strength, for min mm=-1
  
# THE FOLLOWING PARAMETERS ARE OPTIONAL.
particle_size=10         # number of particles
iterations=10           # max number of iterations                    # inertia constant is set to 0.5 for both TS and FS
c1=2                     # cognative constant
c2=2                     # social constant
# END OF THE CUSTOMIZATION SECTION
#------------------------------------------------------------------------------    
# Visualization
#fig = plt.figure()
#ax = fig.add_subplot()
#fig.show()
#------------------------------------------------------------------------------
class Particle:
    def __init__(self,bounds):
        self.particle_position=[]                     # particle position
        self.particle_velocity=[]                     # particle velocity
        self.local_best_particle_position=[]         # best position of the particle
        self.fitness_local_best_particle_position=initial_fitness# initial objective function value of best particle
        self.fitness_particle_position=initial_fitness #objective function value of the particle's position

        for i in range(nv):
            self.particle_position.append(random.uniform(bounds[i][0],bounds[i][1])) # generate random initial position
            self.particle_velocity.append(random.uniform(-1,1)) # generate random initial velocity
         
    def evaluate(self,objective_function):
        self.fitness_particle_position=objective_function(self.particle_position)
        if mm == -1:
            if self.fitness_particle_position < self.fitness_local_best_particle_position:
                self.local_best_particle_position=self.particle_position                  # update the local best
                self.fitness_local_best_particle_position=self.fitness_particle_position  # update the fitness of the local best
        if mm == 1:
            if self.fitness_particle_position > self.fitness_local_best_particle_position:
                self.local_best_particle_position=self.particle_position # update the local best
                self.fitness_local_best_particle_position=self.fitness_particle_position # update the fitness of local

    def update_velocity(self,global_best_particle_position):
        for i in range(nv):
            r1=random.random()
            r2=random.random()
  
            cognitive_velocity = c1*r1*(self.local_best_particle_position[i] - self.particle_position[i])
            social_velocity = c2*r2*(global_best_particle_position[i] - self.particle_position[i])
            self.particle_velocity[i] = w*self.particle_velocity[i]+ cognitive_velocity + social_velocity
  
    def update_position(self,bounds):
        for i in range(nv):
            self.particle_position[i]=self.particle_position[i]+self.particle_velocity[i]
  
            # check and repair to satisfy the upper bounds
            if self.particle_position[i]>bounds[i][1]:
                self.particle_position[i]=bounds[i][1]
            # check and repair to satisfy the lower bounds
            if self.particle_position[i]<bounds[i][0]:
                self.particle_position[i]=bounds[i][0]
              
class PSO():
    def __init__(self,objective_function,bounds,particle_size,iterations):
        fitness_global_best_particle_position=initial_fitness
        global_best_particle_position=[]
  
        swarm_particle=[]
        for i in range(particle_size):
            swarm_particle.append(Particle(bounds))
        A=[]
          
        for i in range(iterations):
            for j in range(particle_size):
                swarm_particle[j].evaluate(objective_function)

                if mm == -1:
                    if swarm_particle[j].fitness_particle_position < fitness_global_best_particle_position:
                       global_best_particle_position = list(swarm_particle[j].particle_position)
                       fitness_global_best_particle_position = float(swarm_particle[j].fitness_particle_position)
                if mm == 1:
                    if swarm_particle[j].fitness_particle_position > fitness_global_best_particle_position:
                        global_best_particle_position = list(swarm_particle[j].particle_position)
                        fitness_global_best_particle_position = float(swarm_particle[j].fitness_particle_position)
            for j in range(particle_size):
                swarm_particle[j].update_velocity(global_best_particle_position)
                swarm_particle[j].update_position(bounds)

            A.append(fitness_global_best_particle_position) # record the best fitness

        weighted_sum = w * global_best_particle_position[0] + w * global_best_particle_position[1]
        Predicted_Fitness.append(weighted_sum)
        #print('\nObjective function value (PSO): ', weighted_sum)

        # Finding out the parameters corresponding to the optimal solution
        arr = np.asarray(fitness_value_list)
        i = (np.abs(arr - weighted_sum)).argmin()
        coordinate = []
        for row in ws.rows:
            for cell in row:
                if row[11].value == arr[i]:
                    coordinate.append(cell.coordinate)
        BO.append(ws[coordinate[1]].value)
        S.append(ws[coordinate[2]].value)
        ID.append(ws[coordinate[3]].value)
        T.append(ws[coordinate[4]].value)
        LT.append(ws[coordinate[5]].value)
        #print('--------------------\nParameters corresponding to the optimal solution are:\nBuild Orientation: ', BO, 'mm\nSpeed: ', S, 'mm/s\nInfill Density: ', ID, '\nTemperature: ', T, '\nLayer Thickness: ', LT)
        #ax.plot(A, color='r')
        #fig.canvas.draw()
        #ax.set_xlim(left=max(0, i - iterations), right = i + 3)
        #plt.show()

if mm == -1:
    initial_fitness = float("inf") # for minimization problem
if mm == 1:
    initial_fitness = -float("inf") # for maximization problem

# main PSO
if __name__ == '__main__':
    begin_time = datetime.datetime.now()
    for i in range (10):
        PSO(objective_function, bounds, particle_size, iterations)
    print("--------------------\nBuild Orientation: ", BO)
    print("Speed: ", S)
    print("Infill Density: ", ID)
    print("Temperature: ", T)
    print("Layer Thickness: ", LT)
    print("Predicted Fitness in Ten Runs: ", Predicted_Fitness, "\n--------------------")
    end_time = datetime.datetime.now()
    runtime_duration = end_time - begin_time
    print("Runtime Duration: ", runtime_duration)
